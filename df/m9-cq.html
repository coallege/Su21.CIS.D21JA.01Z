<!DOCTYPE html><html><head><meta charset="UTF-8"><title>M9: Content Question (Advanced Procedures)</title><link rel="stylesheet" href="style.css"></head><body><div class="topic"><h1>M9: Content Question (Advanced Procedures)</h1><div><p><span>Post questions about&nbsp;Advanced Procedures.</span><span>&nbsp;Use the first line of your post as the subject of the post.</span></p></div></div><table><tbody><tr><td><table class="comment" style="margin-left: 0px;"><tbody><tr><td>married llama</td></tr><tr><td><p>Using MASM directives or do things manually?</p><p>Chapter 8 talks about creating stack frames to manage parameters and local variables.&nbsp; It describes how to use the BSP register to work with stack frames.&nbsp; But it also shows a number of MASM directives that handles the details for us.&nbsp; For example, the MASM ENTER directive generates a few instructions to setup the stack frame and the LEAVE directive generates a few to clean it up.</p><p>I imagine some Intel assemblers may not support the MASM directives.&nbsp; I'm not too familiar with all of the assembler choices but I do know that the GNU assembler does things very differently.&nbsp; I'm tempted to use the cleaner MASM "shortcuts" but I also feel that the saying "no pain, no gain" applies here.&nbsp; If use the individual instructions I might remember the concepts better but I may also might have more typo bugs.</p><p>Do you prefer to use the MASM directives or the do it yourself?</p></td></tr></tbody></table><table class="comment" style="margin-left: 40px;"><tbody><tr><td>similar salamander</td></tr><tr><td><p>The directives seem easier to use. I like to use MASM directives, but I'm not sure which directives we're not supposed to use since the Professor said some directives we can't use.</p></td></tr></tbody></table><table class="comment" style="margin-left: 80px;"><tbody><tr><td>hollow haddock</td></tr><tr><td><p>I am the same, I would like to use MASM directives but not quite sure which ones we are allowed to use, since the professor hasn't lectured chapter 8, and specifically said which ones we can't use</p></td></tr></tbody></table><table class="comment" style="margin-left: 80px;"><tbody><tr><td>clean bovid</td></tr><tr><td><p>I use MASM</p></td></tr></tbody></table><table class="comment" style="margin-left: 40px;"><tbody><tr><td>unsightly toad</td></tr><tr><td><p>I also prefer to use MASM directives which I think we are allowed to use since I don't think it was one of the ones that we can't use.</p></td></tr></tbody></table><table class="comment" style="margin-left: 40px;"><tbody><tr><td>supposed squirrel</td></tr><tr><td><p>I prefer to use MASM. I also do not know which directives we are allowed to know, so sorry about that.</p></td></tr></tbody></table><table class="comment" style="margin-left: 40px;"><tbody><tr><td>hurt harrier</td></tr><tr><td><p>I only know MASM directives</p></td></tr></tbody></table><table class="comment" style="margin-left: 40px;"><tbody><tr><td>encouraging dragon</td></tr><tr><td><p>I think it is always safer to avoid MASM directives if possible as it is not clear if the professor is okay with us using them.</p></td></tr></tbody></table><table class="comment" style="margin-left: 80px;"><tbody><tr><td>cognitive buzzard</td></tr><tr><td><p>Yeah I agree. While it may be easier to use MASM directives, they are not pure assembly which is the point why we are in this class.</p></td></tr></tbody></table><table class="comment" style="margin-left: 40px;"><tbody><tr><td>Cole Gannon</td></tr><tr><td><p>MASM's invoke and abstraction over calling conventions is honestly really great when I want to use stuff in kernel32. Having to deal with passing arguments the stdcall way is cursed and horrible. Being able to declare a proc with parameters is very nice. If you ever end up having to deal with assembly either for gamedev, security, or otherwise, sure, it'd be useful to know how to actually pass arguments but right now, I'll be using as much invoke as I can get my hands on.</p></td></tr></tbody></table><table class="comment" style="margin-left: 40px;"><tbody><tr><td>near mastodon</td></tr><tr><td><p>I also like to use MASM directives but am confused about which ones we can not use. Hopefully, the professor gives us a list on the exam!</p></td></tr></tbody></table><table class="comment" style="margin-left: 40px;"><tbody><tr><td>inland hummingbird</td></tr><tr><td><p>I like using MASM directives but also dont know which ones were allowed to use. Maybe the professor will let us know!</p></td></tr></tbody></table><table class="comment" style="margin-left: 40px;"><tbody><tr><td>broad bird</td></tr><tr><td><p>I personally prefer to MASM as well.</p></td></tr></tbody></table><table class="comment" style="margin-left: 40px;"><tbody><tr><td>alert ant</td></tr><tr><td><p>I honestly just prefer to use MASM directly</p></td></tr></tbody></table><table class="comment" style="margin-left: 40px;"><tbody><tr><td>spectacular silkworm</td></tr><tr><td><p>I prefer MASM directives.</p></td></tr></tbody></table></td></tr><tr><td><table class="comment" style="margin-left: 0px;"><tbody><tr><td>married llama</td></tr><tr><td><p>Why do we need ADDR if we can already use OFFSET?</p><p>Section 8.4.2 discusses using INVOKE with ADDR to pass pointers to procedures.&nbsp; The book says that the argument must be an assembly time constant, like a variable name.&nbsp; But it seems that we can already use OFFSET when passing pointers to variables.</p><p>For example:</p><pre style="padding-left: 40px;">PutText PROTO, SomeString:DWORD<br>.const<br>cMyText BYTE "Don't touch my text!.",0<br>.code<br>INVOKE PutText, ADDR cMyText    ; this works<br>INVOKE PutText, OFFSET cMyText  ; this works too</pre><p>Why do we need ADDR when we can use OFFSET instead?</p></td></tr></tbody></table><table class="comment" style="margin-left: 40px;"><tbody><tr><td>foolish fowl</td></tr><tr><td><p><span>ADDR supports postindexed and preindexed addressing modes. These are:</span></p><dl class="article-list"><dt></dt><dd><p id="B9780128207352000056-p3070">Preindexed: the address for the transfer is calculated with the offset and the base address register is subsequently updated to the accessed address.</p></dd><dt></dt><dd><p id="B9780128207352000056-p3075">Postindexed: the address for the transfer does not include the offset, but the base address register is nonetheless subsequently updated with the offset.</p><p>&nbsp;</p><p>I believe it is a more in depth way of offsetting values (<a href="https://www.sciencedirect.com/topics/engineering/address-offset" target="_blank" class="external" rel="noreferrer noopener"><span>https://www.sciencedirect.com/topics/engineering/address-offset</span><span aria-hidden="true" class="ui-icon ui-icon-extlink ui-icon-inline" title="Links to an external site."></span><span class="screenreader-only">&nbsp;(Links to an external site.)</span></a>)</p></dd></dl></td></tr></tbody></table><table class="comment" style="margin-left: 80px;"><tbody><tr><td>ethnic earthworm</td></tr><tr><td><p>Thank you&nbsp;</p></td></tr></tbody></table><table class="comment" style="margin-left: 80px;"><tbody><tr><td>unfair tick</td></tr><tr><td><p>Ah, I had this same question thanks for the clarification.</p></td></tr></tbody></table><table class="comment" style="margin-left: 80px;"><tbody><tr><td>constitutional cattle</td></tr><tr><td><p>Thanks for clarifying that up and for the link! Helped out alot</p></td></tr></tbody></table><table class="comment" style="margin-left: 80px;"><tbody><tr><td>dry cuckoo</td></tr><tr><td><p>This has helped my confusion. Thanks.&nbsp;</p></td></tr></tbody></table><table class="comment" style="margin-left: 80px;"><tbody><tr><td>continuing centipede</td></tr><tr><td>Thank you.&nbsp;</td></tr></tbody></table><table class="comment" style="margin-left: 80px;"><tbody><tr><td>evolutionary earwig</td></tr><tr><td><p>This helped a lot, thanks!</p></td></tr></tbody></table><table class="comment" style="margin-left: 80px;"><tbody><tr><td>electric dolphin</td></tr><tr><td><p>Hi, this makes it much more clear! Thank you.</p></td></tr></tbody></table><table class="comment" style="margin-left: 80px;"><tbody><tr><td>pleased orca</td></tr><tr><td><p>Thanks for the clarification, so much easier now.</p></td></tr></tbody></table><table class="comment" style="margin-left: 80px;"><tbody><tr><td>useful trout</td></tr><tr><td><p>Thank you!</p></td></tr></tbody></table><table class="comment" style="margin-left: 80px;"><tbody><tr><td>broad bird</td></tr><tr><td><p>Thanks, cleared up the misunderstanding I had.</p></td></tr></tbody></table><table class="comment" style="margin-left: 80px;"><tbody><tr><td>conscious catfish</td></tr><tr><td><p>Thank you for clarifying!</p></td></tr></tbody></table><table class="comment" style="margin-left: 80px;"><tbody><tr><td>ripe python</td></tr><tr><td><p>Thanks a lot or the resource link, that is really helpful!</p></td></tr></tbody></table><table class="comment" style="margin-left: 40px;"><tbody><tr><td>supposed squirrel</td></tr><tr><td><p>Hi there! Here is another resource for you:<a href="https://www.hitxp.com/articles/software/difference-between-addr-and-offset/" target="_blank" class="external" rel="noreferrer noopener"><span>https://www.hitxp.com/articles/software/difference-between-addr-and-offset/</span><span aria-hidden="true" class="ui-icon ui-icon-extlink ui-icon-inline" title="Links to an external site."></span><span class="screenreader-only">&nbsp;(Links to an external site.)</span></a></p><p>&nbsp;</p></td></tr></tbody></table><table class="comment" style="margin-left: 80px;"><tbody><tr><td>broken bird</td></tr><tr><td><p>This was a really helpful read! Thank you for sharing this source.</p></td></tr></tbody></table><table class="comment" style="margin-left: 40px;"><tbody><tr><td>regulatory pony</td></tr><tr><td><p>This could be a helpful source:</p><p><a href="http://www.c-jump.com/CIS77/ASM/Instructions/I77_0220_addr_n_offset.htm" target="_blank" class="external" rel="noreferrer noopener"><span>http://www.c-jump.com/CIS77/ASM/Instructions/I77_0220_addr_n_offset.htm</span><span aria-hidden="true" class="ui-icon ui-icon-extlink ui-icon-inline" title="Links to an external site."></span><span class="screenreader-only">&nbsp;(Links to an external site.)</span></a></p><p>&nbsp;</p></td></tr></tbody></table><table class="comment" style="margin-left: 80px;"><tbody><tr><td>adverse anaconda</td></tr><tr><td><p>Thanks for the link that helps understand the addr operator.</p></td></tr></tbody></table><table class="comment" style="margin-left: 40px;"><tbody><tr><td>striking snipe</td></tr><tr><td><p>Good question! I didn't think of this, until I read your question and the links posted here in the replies.</p><p>So effectively it translates to usage of OFFSET when the variables are declared before hand, however if we need to get the address of undeclared variables which is local to a procedure,&nbsp; ADDR will get the latest stack address using LEA (load effective address) and push the declared local variable onto stack.&nbsp;</p></td></tr></tbody></table></td></tr><tr><td><table class="comment" style="margin-left: 0px;"><tbody><tr><td>thoughtless swordtail</td></tr><tr><td><h2>Procedure return values</h2><p>How can procedures return values. For example, how would the following return a value</p><p><code>int add(x, y)<br>{<br>&nbsp;&nbsp;&nbsp;&nbsp;return x + y;<br>}<br></code></p><p>Would this return a value by referencing the local variable in the caller's stack frame by adding to ebp?</p></td></tr></tbody></table><table class="comment" style="margin-left: 40px;"><tbody><tr><td>federal firefly</td></tr><tr><td>In most of the examples and the MS calling convention, return values are saved in a register. This prevents corrupting the already balanced stack outside of your procedure.</td></tr></tbody></table><table class="comment" style="margin-left: 40px;"><tbody><tr><td>early deer</td></tr><tr><td><p>Hi Ronak,</p><p>I think that you often designate a register to store the return value. Since this register's value needs to be saved after the procedure is called, you should not push and pop its original value as you may do for some other registers, which have values that need to be preserved. This means that you would not be using the USES mnemonic.&nbsp;</p></td></tr></tbody></table><table class="comment" style="margin-left: 40px;"><tbody><tr><td>forward frog</td></tr><tr><td><p>I agree with Aryan. You just move the value into a register where you can later use it.</p></td></tr></tbody></table></td></tr><tr><td><table class="comment" style="margin-left: 0px;"><tbody><tr><td>robust quail</td></tr><tr><td><p>is it possible to import files?</p></td></tr></tbody></table><table class="comment" style="margin-left: 40px;"><tbody><tr><td>itchy junglefowl</td></tr><tr><td><p>you can import using AS</p><p>here is a good reference:</p><p>https://stackoverflow.com/questions/64017319/proper-way-to-do-imports-with-gas</p></td></tr></tbody></table></td></tr><tr><td><table class="comment" style="margin-left: 0px;"><tbody><tr><td>grand gopher</td></tr><tr><td><p>The textbook says "The subroutines, in turn, usually store their local variables on the stack." but I thought languages like C / C++ would store in memory, if it was in the stack wouldn't it always have to juggle the data around? I could understand pushing arguments and such, but I'm not sure. This makes me want to read some of my old 22A/22B/22C labs in assembly.</p></td></tr></tbody></table><table class="comment" style="margin-left: 40px;"><tbody><tr><td>dry cuckoo</td></tr><tr><td><p>Same here - I feel that my previous knowledge got challenged as I am reading through how variable works at assembly level...</p></td></tr></tbody></table></td></tr><tr><td><table class="comment" style="margin-left: 0px;"><tbody><tr><td>total takin</td></tr><tr><td><p>Out of curiosity, what's the 64-bit equivalent of the INVOKE directive?&nbsp;</p></td></tr></tbody></table></td></tr><tr><td><table class="comment" style="margin-left: 0px;"><tbody><tr><td>gradual gopher</td></tr><tr><td><p>Two possible ways of calling DumpMem. Which is easier?</p><p>pushad</p><p>mov esi, OFFSET array</p><p>mov ecx, LENGTHOF array</p><p>mov ebx, TYPE array</p><p>call DumpMem</p><p>popad&nbsp;</p><p>OR</p><p>push TYPE array</p><p>push LENGTHOF array</p><p>push OFFSET array</p><p>call DumpMem</p></td></tr></tbody></table><table class="comment" style="margin-left: 40px;"><tbody><tr><td>evident earwig</td></tr><tr><td><p>I think the second code shown in the textbook was just hypothetical, that&nbsp;<strong>if&nbsp;</strong>dumpmem used stack parameters, that would be the code, and only the first code will actually work.</p></td></tr></tbody></table></td></tr><tr><td><table class="comment" style="margin-left: 0px;"><tbody><tr><td>evident earwig</td></tr><tr><td><p><strong>Number used with ret</strong></p><p>I don't understand what the number used with ret means, which is apparently used to clean up the stack. Is it the number of values on the stack used by the procedure? Is it the total memory of them?</p></td></tr></tbody></table><table class="comment" style="margin-left: 40px;"><tbody><tr><td>evident earwig</td></tr><tr><td><p>I think the optional number parameter is used to specify the number of stack bytes or words to be released after the return address is popped from the stack.&nbsp;</p></td></tr></tbody></table></td></tr><tr><td><table class="comment" style="margin-left: 0px;"><tbody><tr><td>radical pigeon</td></tr><tr><td><p>Can anyone explain how stack frames work?</p></td></tr></tbody></table></td></tr></tbody></table></body></html>