{"topic":{"title":"M2: Content Question (Basic Concepts)","time":null,"msg":"<p><span>Post questions about basic computer architecture.</span><span>&nbsp;Use the first line of your post as the subject of the post.</span></p>"},"replies":[{"id":"entry-2931987","entry":{"title":"secure salamander","time":"2021-07-02T10:37:56.000Z","msg":"<p><strong><span style=\"font-size: 18pt;\">Virtual Machines and Virtual Machine Concepts</span></strong></p>\n<p><span style=\"font-size: 12pt;\">Still a little confused on VMs and its concepts. For VMs, it says that if, for example, you have 2 VMs, VM1 and VM0. We use VM1 using L1 to talk to VM0 that uses L0. Here's where I'm confused. If we needed to create another VM for easier to understand language, VM2, would it still be using L1 or would it use a step above that with L2 and so on and so forth the more VMs we add?</span></p>"},"replies":[{"id":"entry-2933344","entry":{"title":"spatial snipe","time":"2021-07-02T23:54:21.000Z","msg":"<p>Let countries are VMs, languages as L0, L1, and&nbsp; Google Translate is High level language VM2</p>\n<p>USA VM0 - understands English (L0)</p>\n<p>France VM1 - understand French (L1)</p>\n<p>As a german user (L2), uses Google Translate VM2 to feed instructions and get translated output in german.</p>\n<p>Here Google Translate VM2 - knows how to process German (L2) language, converts it to L0/L1 based on user selection of language, process the instruction and replies back in its respective language, which in turn gets converted into German (L2) so the german user can understand.</p>\n<p>High level languages are similar to that. There are many such L2 languages that are similar to Google Translate, like Microsoft Bing Translate, Apple Translate etc (similar to Java, C++, Python etc)</p>\n<p>Hope its clears up with the analogy.</p>"},"replies":[]},{"id":"entry-2933386","entry":{"title":"statutory squirrel","time":"2021-07-03T00:12:52.000Z","msg":"<p>Well the entire point of VM2 is to make it easier for the user to program, so you would use a higher level language (L2, common high-level language you code in). The code is then converted to a much lower level language (For example: assembly or bytecode). The lower level language can then directly be mapped to machine code (1's and 0's).&nbsp;</p>\n<p>Pretty much yea, I believe you will have a be using a new language (L2) which will be then converted to (L0).&nbsp;</p>\n<p>P.S: I would also ask the professor about this since he may be able to provide even more interesting info, but this was just my way of explaining. Hope this helps.</p>"},"replies":[]},{"id":"entry-2935532","entry":{"title":"loose llama","time":"2021-07-03T19:31:12.000Z","msg":"<p>I agree that the way the specific documentation uses the term Virtual Machine is confusing.</p>\n<p>I think some of the confusion here might be due to the way we use the term Virtual Machine these days.&nbsp;</p>\n<p>I often use VirtualBox to a run Ubuntu in a Virtual Machine.&nbsp; In this case, the VirtualBox software is \"simulating\" a PC.&nbsp; The simulated PC is a \"virtual machine\".&nbsp; In this use case, because the Virtual Client Machine and Real Host Machine are both Intel x86 based PC platforms, VirtualBox doesn't really need to translate machine language instructions much but it does need to intercept and translate system calls for I/O and memory and such.&nbsp; Emulators such as \"qemu\" provide virtual machines that do simulate different hardware so they must translate machine language instructions as well.</p>\n<p>The Java Virtual Machine, or JVM, is a bit different.&nbsp; It is not \"simulating\" a PC or other real hardware platform.&nbsp; Instead, the entire platform is a software implementation (though it should be possible to create a Java hardware platform and probably someone did that already, just for fun).&nbsp; In this case, the JVM operates like an interpreter such as a Python interpreter.&nbsp; It reads and parses each command (Java Bytecode instruction) and runs it.&nbsp; It is similar to a hardware emulator such as qemu but its hardware is essentially \"imaginary\".&nbsp; The Java \"CPU\" is a software based CPU that doesn't simulate an existing CPU at all.&nbsp; The advantage is that a program can be written to simulate the JVM on any hardware.&nbsp; The JVM was specifically designed to simplify this task since portability is its main objective.</p>\n<p>The documentation seems to be using the term to describe a level of instruction translation.&nbsp; Both of my examples above illustrate how a few modern Virtual Machines generally operate.&nbsp; They <em>do</em> translate instructions from a \"virtual machine\" to a \"real hardware machine\".&nbsp; The book refers to the various instruction set layers as Virtual Machines.&nbsp; For example, Python could be thought of as a virtual machine that uses its own instruction set and memory model.&nbsp; That would be a higher level \"VM\" per the book such as L4.&nbsp; A lower level might be the Intel microcode interpreter that translates machine code into microcode that the lowest level transistors operate on.&nbsp; In the book, L1 is the microcode interpreter and L0 is the digital logic made of physical silicon (or other) components.&nbsp; This usage is fine but it becomes confusing when you consider that a C++ compiler or x86 Assembler doesn't really fit that model very well.&nbsp; A compiler or assembler it isn't actively \"running\" any code to simulate a virtual machine.&nbsp; Indeed, you may \"cross-compile\" a program on one platform to run on another platform.</p>\n<p>I would guess that if Andrew Tanenbaum’s book, Structured Computer Organization, was written today, he may chosen another term to avoid confusion with how we generally use them \"Virtual Machine\" today.&nbsp; Here is a snip from the book's intro:</p>\n<p>\"Rather than thinking in terms of translation or interpretation, it is often simpler to imagine the existence of a hypothetical computer or virtual machine whose machine language is L1. Let us call this virtual machine M1 (and let us call the machine corresponding to L0, M0).\"</p>\n<p>Well, these days we don't imagine a hypothetical computer or virtual machine, we run them.&nbsp; I use them daily.&nbsp; My phone runs them.&nbsp; It's a different era.</p>"},"replies":[]}]},{"id":"entry-2933609","entry":{"title":"passive owl","time":"2021-07-03T01:36:56.000Z","msg":"<h3><strong>The relationship between Java Virtual Machine and Virtual Machine</strong></h3>\n<p>The chapter mentioned <span>Virtual Machine, I am not clear that what the relationship is between Java Virtual Machine and Virtual Machine. Is Java Virtual Machine a kind of Virtual Machine? What's the difference?</span></p>\n<p>&nbsp;</p>\n<p>&nbsp;</p>"},"replies":[{"id":"entry-2934130","entry":{"title":"statutory squirrel","time":"2021-07-03T04:14:03.000Z","msg":"<p>Well JVM of Java Virtual Machine has been created to run Java class files (or thats what I think it was created for). It is essentially a virtual processor, while a normal Virtual Machine has virtual video card, network, etc. It is pretty much a program virtual machine (just for Java Program) and isn't like your typical virtual machine.&nbsp;</p>\n<p>Here are some resources (I used some) for further clarification:</p>\n<p><a href=\"https://www.programmersought.com/article/54486880694/\" target=\"_blank\" class=\"external\" rel=\"noreferrer noopener\"><span>https://www.programmersought.com/article/54486880694/</span><span aria-hidden=\"true\" class=\"ui-icon ui-icon-extlink ui-icon-inline\" title=\"Links to an external site.\"></span><span class=\"screenreader-only\">&nbsp;(Links to an external site.)</span></a></p>\n<p><a href=\"https://www.quora.com/What-is-the-difference-between-JVM-and-Virtual-machine-for-computers\" target=\"_blank\" class=\"external\" rel=\"noreferrer noopener\"><span>https://www.quora.com/What-is-the-difference-between-JVM-and-Virtual-machine-for-computers</span><span aria-hidden=\"true\" class=\"ui-icon ui-icon-extlink ui-icon-inline\" title=\"Links to an external site.\"></span><span class=\"screenreader-only\">&nbsp;(Links to an external site.)</span></a></p>\n<p><a href=\"https://en.wikipedia.org/wiki/Java_virtual_machine\" target=\"_blank\" class=\"external\" rel=\"noreferrer noopener\"><span>https://en.wikipedia.org/wiki/Java_virtual_machine</span><span aria-hidden=\"true\" class=\"ui-icon ui-icon-extlink ui-icon-inline\" title=\"Links to an external site.\"></span><span class=\"screenreader-only\">&nbsp;(Links to an external site.)</span></a></p>\n<p><a href=\"https://www.infoworld.com/article/3272244/what-is-the-jvm-introducing-the-java-virtual-machine.html#:~:text=The%20JVM%20is%20a%20virtual,files%20in%20a%20portable%20way.&amp;text=Regardless%20of%20what%20operating%20system,create%20a%20virtual%20operating%20system\" target=\"_blank\" class=\"external\" rel=\"noreferrer noopener\"><span>https://www.infoworld.com/article/3272244/what-is-the-jvm-introducing-the-java-virtual-machine.html#:~:text=The%20JVM%20is%20a%20virtual,files%20in%20a%20portable%20way.&amp;text=Regardless%20of%20what%20operating%20system,create%20a%20virtual%20operating%20system</span><span aria-hidden=\"true\" class=\"ui-icon ui-icon-extlink ui-icon-inline\" title=\"Links to an external site.\"></span><span class=\"screenreader-only\">&nbsp;(Links to an external site.)</span></a>.</p>\n<p>&nbsp;</p>"},"replies":[]},{"id":"entry-2935110","entry":{"title":"Cole Gannon","time":"2021-07-03T09:36:23.000Z","msg":"<p>A virtual machine just acts as a middleman between your real, physical processor and the instructions that are running. Virtual machines like what you get through Virtual Box or VMWare do a sorta similar thing to the JVM except in a much more robust and comprehensive way. Both act as a translation layer between instructions run in the machine and what's really running on the processor. The cool part about having virtual machines is that you can have one set of instructions that runs anywhere, provided that where you're trying to run it has something to translate those instructions. Class files produced by javac on my windows computer will run just fine on someone else's linux computer. The Java bytecode (instructions) are the same on both Windows and Linux but the Java Virtual Machine takes care in translating them accordingly so that they work in both environments.</p>"},"replies":[]},{"id":"entry-2935758","entry":{"title":"insufficient junglefowl","time":"2021-07-03T21:24:53.000Z","msg":"<p>JVM is a virtualized processor while other virtual machines are virtualized machines. We call JVM a virtual machine because the JVM definition defines an abstract machine.</p>"},"replies":[]},{"id":"entry-2936957","entry":{"title":"puzzled pony","time":"2021-07-04T05:22:43.000Z","msg":"<p>Here's a good in-depth article on the JVM</p>\n<p><a href=\"https://www.freecodecamp.org/news/jvm-tutorial-java-virtual-machine-architecture-explained-for-beginners/\" class=\"external\" target=\"_blank\" rel=\"noreferrer noopener\"><span>JVM Tutorial - Java Virtual Machine Architecture Explained for Beginners (freecodecamp.org)</span><span aria-hidden=\"true\" class=\"ui-icon ui-icon-extlink ui-icon-inline\" title=\"Links to an external site.\"></span><span class=\"screenreader-only\">&nbsp;(Links to an external site.)</span></a></p>\n<p>Essentially, Java programs are <span>known for the \"Write once, run anywhere\" principle. This means a Java program can run on any device or OS that implements the JVM specification . JVM architecture commonly consists of a Class Loader, Runtime Data Area, and Execution Engine.&nbsp; Java code is compiled into Java byte code (.class file) then the .class file is executed/run by the JVM.</span></p>\n<p>From the article:&nbsp;</p>\n<p>\"<em>Similar to virtual machines,</em><span>&nbsp;the JVM creates an isolated space on a host machine. This space can be used to execute Java programs irrespective of the platform or operating system of the machine.\"</span></p>\n<p>&nbsp;</p>\n<p>&nbsp;</p>"},"replies":[]},{"id":"entry-2938083","entry":{"title":"implicit hoverfly","time":"2021-07-04T19:33:47.000Z","msg":"<p>JVM is software that acts as a translator between Java byte code and the computer's operating system so that Java-written applications can be used in Windows, UNIX, and so on. A virtual machine is a software implementation of a computing environment, that is, software that emulates a computer systems.</p>"},"replies":[{"id":"entry-2938351","entry":{"title":"dizzy cuckoo","time":"2021-07-04T21:11:57.000Z","msg":"<p>Thanks for this discussion. I developed Java applications in the past and my understanding is that JRE is the execution environment and JVM is part of the larger JRE.&nbsp;</p>\n<p>Picture taking from <a href=\"https://www.geeksforgeeks.org/differences-jdk-jre-jvm/\" target=\"_blank\" class=\"external\" rel=\"noreferrer noopener\"><span>https://www.geeksforgeeks.org/differences-jdk-jre-jvm/</span><span aria-hidden=\"true\" class=\"ui-icon ui-icon-extlink ui-icon-inline\" title=\"Links to an external site.\"></span><span class=\"screenreader-only\">&nbsp;(Links to an external site.)</span></a></p>\n<p>&nbsp;</p>\n<p><img src=\"https://deanza.instructure.com/users/182305/files/5521026/preview?verifier=LmJcSmbiXtfZCANRA0c46evcgduDoyL2tnJvkzYU\" alt=\"JDK_JRE_JVM_x.jpg\" data-api-endpoint=\"https://deanza.instructure.com/api/v1/users/182305/files/5521026\" data-api-returntype=\"File\" style=\"max-width: 453px;\">&nbsp;</p>\n<p>&nbsp;</p>\n<p>Currently, JVM doesn't only support Java native applications but also expanded its support to other languages <span>that are also compiled to Java bytecode, such as Groovy, Kotlin, Scala and Clojure.&nbsp;</span></p>"},"replies":[{"id":"entry-2939806","entry":{"title":"surviving takin","time":"2021-07-05T05:46:56.000Z","msg":"<p>Thank you for this illustration, it's very helpful!</p>"},"replies":[]}]}]}]},{"id":"entry-2935994","entry":{"title":"tough toad","time":"2021-07-03T23:27:26.000Z","msg":"<p><span style=\"font-size: 14pt;\"><strong>Two's complement</strong></span></p>\n<p>I'm a little confused on what exactly two's complement is. In the textbook, it says that when converting signed hexadecimal to decimal, if the hexadecimal int is negative, create its two's complement. How are we supposed to do that?&nbsp;</p>"},"replies":[{"id":"entry-2937116","entry":{"title":"advanced anaconda","time":"2021-07-04T05:59:18.000Z","msg":"<p>Hi Nikita,</p>\n<p>I am not sure if you are asking what two's complement of a number is. Here are my findings:</p>\n<p>Follow these three steps to get two's complement of a negative number:</p>\n<p>Step 1: Write the absolute value of the given number in binary form. Prefix this number with 0 indicate that it is positive.<br>Step 2: Take the complement of each bit by changing zeroes to ones and ones to zero.<br>Step 3: Add 1 to your result. This is the two’s complement representation of the negative integer.</p>\n<p><br>EXAMPLE: Find the two’s complement of -17<br>Step 1: 17<sub>10</sub> = 0001 0001<sub>2</sub><br>Step 2: Take the complement: 1110 1110<br>Step 3: Add 1: 1110 1110 + 1 = 1110 1111</p>"},"replies":[{"id":"entry-2937286","entry":{"title":"advanced anaconda","time":"2021-07-04T06:31:13.000Z","msg":"<p>From the text book, the Hexadecimal Two’s Complement can be performed like this:</p>\n<p>To create the two’s complement of a hexadecimal integer,<br>reverse all bits and add 1. An easy way to reverse the bits of a hexadecimal digit is to subtract the<br>digit from 15. Here are examples of hexadecimal integers converted to their two’s complements:<br>6A3D --&gt; 95C2 + 1 --&gt; 95C3<br>95C3 --&gt; 6A3C + 1 --&gt; 6A3D</p>"},"replies":[]},{"id":"entry-2939455","entry":{"title":"entitled earwig","time":"2021-07-05T04:21:31.000Z","msg":"<p>Hi,</p>\n<p>I derived why this is true, and thought it was quite cool, so here it is:</p>\n<p>If you have a number x, and you perform the steps:</p>\n<p>The non sign bits in step 2 give you 11111111... - x = (2^(w-1) - 1) - x. The sign bit is -2^w, so it becomes -1-x.</p>\n<p>Finally, adding one in step 3 makes it -x, which is why it works.</p>"},"replies":[{"id":"entry-2999157","entry":{"title":"relaxed python","time":"2021-07-27T02:44:33.000Z","msg":"<p>Thank you so much, it is really helpful!</p>"},"replies":[]}]}]},{"id":"entry-2937845","entry":{"title":"electoral dragon","time":"2021-07-04T17:01:54.000Z","msg":"<p>Hello Nikita,</p>\n<p>In addition to what Sarah mentioned, I would recommend looking at more examples and explanations here: <a class=\"anchor-3Z-8Bb anchorUnderlineOnHover-2ESHQB external\" title=\"https://www.cs.cornell.edu/~tomf/notes/cps104/twoscomp.html\" role=\"button\" href=\"https://www.cs.cornell.edu/~tomf/notes/cps104/twoscomp.html\" target=\"_blank\" rel=\"noreferrer noopener\"><span>https://www.cs.cornell.edu/~tomf/notes/cps104/twoscomp.html</span><span aria-hidden=\"true\" class=\"ui-icon ui-icon-extlink ui-icon-inline\" title=\"Links to an external site.\"></span><span class=\"screenreader-only\">&nbsp;(Links to an external site.)</span></a></p>\n<p>This helped a lot for the hw assignments!</p>"},"replies":[{"id":"entry-2940246","entry":{"title":"abstract aardwolf","time":"2021-07-05T06:57:15.000Z","msg":"<p>Hi Yash,</p>\n<p>Thanks for the link, it was very helpful.</p>"},"replies":[]}]}]},{"id":"entry-2937176","entry":{"title":"financial fowl","time":"2021-07-04T06:10:21.000Z","msg":"<p><span style=\"font-size: 24pt;\">The difference between IA32 and x86-64</span></p>\n<p><span style=\"font-size: 12pt;\">I was wondering why these two things are important in our module and what they represent. Are they machine competitors, and if so, what are the pros and cons of each? Please let me know. Thanks!</span></p>"},"replies":[{"id":"entry-2937548","entry":{"title":"supposed swordtail","time":"2021-07-04T07:54:51.000Z","msg":"<p>Hello Arnav,</p>\n<p>IA32 is the architecture with a 32-bit version of the x86 instruction set. x86-64 is the architecture with a 64-bit instruction set. The advantages of x86-64 to IA32 are the same advantages of using 64 bit vs 32 bit such as larger hardware numbers and more RAM.</p>"},"replies":[]}]},{"id":"entry-2937650","entry":{"title":"wasteful wildebeest","time":"2021-07-04T10:22:16.000Z","msg":"<h2>VM Concept</h2>\n<p>I understand to a certain extent that VM is used to unify the software and hardware of a computer and give scenarios, but I don't really understand how it works and all the L0 and L1 stuff. So is it if L0 and L1 are similar and can back off of each other like say a anti cheat client and the game itself? Can someone give me an example please.</p>"},"replies":[{"id":"entry-2939549","entry":{"title":"grumpy haddock","time":"2021-07-05T04:48:57.000Z","msg":"<p>L0 and L1 are basically levels in the virtual machine concepts which represent a language, and their job is to make it easier to code. In the example provided by the book, L0 is the hardware, L1 is the ISA coded in machine language, L2 is Assembly language, and L3 is high level language. As you can see, as you progress upward, it is simpler for the user to code.</p>"},"replies":[]}]},{"id":"entry-2937793","entry":{"title":"occasional muskox","time":"2021-07-04T16:02:47.000Z","msg":"<h3>Interpreted vs. Compiled Languages</h3>\n<p>Is the only difference between a fully interpreted and a fully compiled language that one is run through and checked beforehand? Could I have such a thing as a Java or C++ interpreter and not have to compile my code beforehand?</p>"},"replies":[{"id":"entry-2939061","entry":{"title":"impressive hummingbird","time":"2021-07-05T02:22:54.000Z","msg":"<p>Hi Arjun! The main difference between interpreted and compiled languages is that interpreted language executes instructions directly, without compiling a program into machine-language instructions first. Another difference is that in compiled language compilation errors prevent code from compiling, while in interpreted language all the debugging happens at runtime. Theres some more information about the differences and pros and cons here https://www.freecodecamp.org/news/compiled-versus-interpreted-languages/</p>"},"replies":[]},{"id":"entry-2939664","entry":{"title":"driving deer","time":"2021-07-05T05:16:08.000Z","msg":"<p>Hey Arjun,</p>\n<p>I found this to be a really useful resource that covers the difference between interpreted and compiled languages: <a href=\"https://www.baeldung.com/java-compiled-interpreted\" class=\"external\" target=\"_blank\" rel=\"noreferrer noopener\"><span>Is Java a Compiled or Interpreted Language? | Baeldung</span><span aria-hidden=\"true\" class=\"ui-icon ui-icon-extlink ui-icon-inline\" title=\"Links to an external site.\"></span><span class=\"screenreader-only\">&nbsp;(Links to an external site.)</span></a>. In addition, it takes a look at the Java Virtual Machine (JVM) architecture and Just in Time compiler. What's interesting is that Java actually uses a combination of the Interpreter and JIT compiler. I do not know of any specific method to avoid the compiler in Java or C++. Either way you probably do not need to bother especially if you use an IDE since it much simpler to test and run your code.</p>"},"replies":[]},{"id":"entry-2939741","entry":{"title":"brief bird","time":"2021-07-05T05:31:54.000Z","msg":"<p>Hey Arjun! I found this website to be really helpful in describing the difference between the two. It also lists some benefits and examples of each.</p>\n<p>https://www.theserverside.com/answer/Interpreted-vs-compiled-languages-Whats-the-difference</p>\n<p>Hope this helps!</p>\n<p>&nbsp;</p>"},"replies":[]}]},{"id":"entry-2938091","entry":{"title":"enormous earthworm","time":"2021-07-04T19:38:22.000Z","msg":"<p><span style=\"font-size: 36pt;\"><strong>Boolean Expressions</strong></span><br>The book notes all these expressions:<br>• NOT: notated as ¬ or ~ or ’<br>• AND: notated as ∧ or •<br>• OR: notated as ∨ or +</p>\n<p><br>Languages like Java and C++ these expressions are represented as or ||, Not !, And &amp;&amp;. My question is why does assembly have 2-3 methods for representing the same thing but in the book only uses the first one symbols when showing examples?<br><br></p>"},"replies":[{"id":"entry-2938423","entry":{"title":"conscious cattle","time":"2021-07-04T21:46:18.000Z","msg":"<p>Hi Jason,&nbsp;</p>\n<p>In most programming languages, the AND, OR and NOT operators are represented by &amp;&amp;, || and ! respectively as you might have seen in Java and C++.</p>\n<p>However, in mathematics literature, the symbols used are “~” for negation or NOT, “<span>∨” for OR and “∧” for AND operator.</span></p>\n<p><span>I think it’s more like a different notation for high-level programming languages and mathematics literature.&nbsp;</span></p>"},"replies":[{"id":"entry-2939775","entry":{"title":"thin tick","time":"2021-07-05T05:39:19.000Z","msg":"<p>I agree with Ajay's response. I took discreet mathematics last quarter, and for mathematical statements you would use <span>∧ for and, ∨ for or, and ~ for negation. The other symbols, such as + for or is when you are using boolean logic and are attempting to do a boolean operation.</span></p>"},"replies":[]}]},{"id":"entry-2939850","entry":{"title":"entitled earwig","time":"2021-07-05T05:55:01.000Z","msg":"<p>I agree with Ajay! In a discrete mathematics class I took last semester, they taught us how written programming and interpretation are different from what we actually code, which is why it's important to know of both. I think the textbook only contains one sort of way because they want us to understand the assembly and not interpret and write code from it or create some software so we wouldn't need the exact language for writing the program. I think that's just my understanding of the topic.</p>"},"replies":[]},{"id":"entry-2939872","entry":{"title":"surviving takin","time":"2021-07-05T05:58:57.000Z","msg":"<p>To put it simply, it's all for historical reasons. The first programming languages, notably ALGOL, utilized those characters you listed (<span>∧, ∨, </span><span>¬) for logical operations all the way back in the 60s. Well if you look down to your keyboard you will quickly realize that you cannot find those character keys for you to type with! Here's a <a class=\"inline_disabled external\" href=\"https://jkorpela.fi/latin1/ascii-hist.html#7C\" target=\"_blank\" rel=\"noreferrer noopener\"><span>history</span><span aria-hidden=\"true\" class=\"ui-icon ui-icon-extlink ui-icon-inline\" title=\"Links to an external site.\"></span><span class=\"screenreader-only\">&nbsp;(Links to an external site.)</span></a> of the characters that were \"approved\" for the ASCII values and you will notice that those three are omitted. This led to &amp; and | being used to represent AND, OR, respectively and somewhere along the way I believe they doubled up to &amp;&amp; and II so as not to misconstrue this logical operator for a bitwise operator.&nbsp;</span></p>"},"replies":[]},{"id":"entry-2939914","entry":{"title":"envious earwig","time":"2021-07-05T06:07:39.000Z","msg":"Hi Jason!<br><br>Here's a link to a forum that may help you understand the necessity of boolean algebra and its symbols:&nbsp;https://stackoverflow.com/questions/14568094/is-boolean-algebra-really-necessary-for-assembly-programming"},"replies":[]}]},{"id":"entry-2938345","entry":{"title":"conscious cattle","time":"2021-07-04T21:10:50.000Z","msg":"<p><span style=\"font-size: 14pt;\"><strong>Boolean Algebra - Digital gate diagram for OR and AND operator</strong></span></p>\n<p><span style=\"font-size: 12pt;\">To compute the logical equivalency of our statements, we use the truth table values. However, I am still confused about the digital gate diagram for AND and OR operator and how to differentiate between the two? What is its significance?</span></p>\n<p>&nbsp;</p>"},"replies":[{"id":"entry-2940195","entry":{"title":"skilled silkworm","time":"2021-07-05T06:49:04.000Z","msg":"<p>Hi Ajay,</p>\n<p>Thank you for posting such an informative topic. As we know that in mathematics, Algebra is just a set of formulas that we imply where there are sets of rules and symbols to watch out for where we deal with add, subtract, multiply and divide. In a similar way, Boolean Algebra works but since it will be with a logical statement working with conjunctions, disjunctions, and negation meaning not true of the given statement.</p>\n<p>I am pretty sure we have used this type of function in our programming classes.</p>\n<p>Here is the link that I always refer to: <a class=\"inline_disabled external\" href=\"https://javascript.info/logical-operators\" target=\"_blank\" rel=\"noreferrer noopener\"><span>https://javascript.info/logical-operators</span><span aria-hidden=\"true\" class=\"ui-icon ui-icon-extlink ui-icon-inline\" title=\"Links to an external site.\"></span><span class=\"screenreader-only\">&nbsp;(Links to an external site.)</span></a></p>\n<p>Hope this helps.&nbsp;</p>"},"replies":[]},{"id":"entry-2940263","entry":{"title":"close buzzard","time":"2021-07-05T06:59:16.000Z","msg":"<p>Hello,</p>\n<p>This concept is essential for programming if you take that path. This link seems to help me and it even gives the truth tables for all of the gates.</p>"},"replies":[]}]},{"id":"entry-2939108","entry":{"title":"civic bovid","time":"2021-07-05T02:36:54.000Z","msg":"<p><span style=\"font-size: 18pt;\"><strong>Memory Blocks</strong></span></p>\n<p><span>What is the easiest way to determine cache locations in which to store memory blocks?</span></p>"},"replies":[{"id":"entry-2939360","entry":{"title":"magnificent louse","time":"2021-07-05T03:55:42.000Z","msg":"I think&nbsp;the simplest way to determine cache locations in which to store memory blocks is the direct mapping."},"replies":[]}]},{"id":"entry-2939141","entry":{"title":"geographical gopher","time":"2021-07-05T02:46:35.000Z","msg":"<p>Are we still getting lied to or misled when programming assembly? Something mentioned in the video was flat addressing, which allowed memory to be addressed in one block instead of split up. I know when we're dealing with high level languages we never get to see exactly where an array is stored in memory for example. When we're dealing with this low of a level, and memory is split between chips on a single ram piece or split in other ways, do we see that or have to work around it?&nbsp;</p>"},"replies":[{"id":"entry-2939663","entry":{"title":"faithful firefly","time":"2021-07-05T05:15:50.000Z","msg":"<p>Flat addressing + virtual memory means that we don't have to worry about the structure of the memory, it's treated as one monolithic \"virtual memory\" which encompasses memory and storage (and maybe L3/L2/L1 cache?) Before this development, you'd need to use paging to move data from some types data storage into memory before operating on them, and write various code handling hardware oddities. Developments in CPU design have made this extra code unnecessary, making programming easier.</p>"},"replies":[]}]},{"id":"entry-2939695","entry":{"title":"consistent centipede","time":"2021-07-05T05:21:42.000Z","msg":"<p>In the textbook, it mentions a companion program called a linker, which combines individual files created by an assembler into a single executable program, and a debugger that provides ways for programmers to trace the execution of a program and examine contents of a memory. Are these companion programs necessary for the assembler to run? Or is it just something in addition to the assembler that would make utilizing it easier?&nbsp;</p>"},"replies":[{"id":"entry-2939957","entry":{"title":"moaning mastodon","time":"2021-07-05T06:14:15.000Z","msg":"<p>Linkers are required for the program to run because it \"links\" all parts together for it to be executable. In theory, a debugger should not be required in an assembler because in a perfect world, there would be no mistakes, so I believe it is not needed but makes it easier to use it.</p>"},"replies":[]},{"id":"entry-2939963","entry":{"title":"easy dolphin","time":"2021-07-05T06:14:40.000Z","msg":"<p>Hi Michael. My understanding is that the linker would act if the assembler creates multiple individual files based on the executable code a programmer writes. So it looks like the linker and debugger would begin functioning after the assembler is done translating the assembly language to machine language. I think this would mean that the assembler doesn't necessarily need a linker and debugger in order to function?</p>"},"replies":[]},{"id":"entry-2940212","entry":{"title":"decent condor","time":"2021-07-05T06:53:27.000Z","msg":"<p>linker is necessary as some aspects of address resolution cannot be handled by the assembler alone.&nbsp;For example, to support relocatable code modules require usage of linkers</p>"},"replies":[]}]},{"id":"entry-2939896","entry":{"title":"ugliest trout","time":"2021-07-05T06:03:56.000Z","msg":"<p><span style=\"font-size: 18pt;\"><strong>Access levels for input–output operations.</strong></span></p>\n<p>How to understand the four lever (Application program, OS function, BIOS function, Hardware) in a easy way</p>"},"replies":[]},{"id":"entry-2939981","entry":{"title":"agricultural ant","time":"2021-07-05T06:16:17.000Z","msg":"<h2>And/OR</h2>\n<p>&nbsp;</p>\n<p>What is the best way to differentiate between the And and OR comparator when writing assembly code?</p>"},"replies":[]},{"id":"entry-2939994","entry":{"title":"overseas orca","time":"2021-07-05T06:18:58.000Z","msg":"<p><strong>Linkers</strong></p>\n<p>Can someone elaborate on what a linker actually does? I came across it in the textbook and was unsure of what purpose it serves in computer architecture.</p>"},"replies":[]},{"id":"entry-2940104","entry":{"title":"conceptual catfish","time":"2021-07-05T06:35:02.000Z","msg":"<p>Does anyone have any resources to better understand hexadecimal operations?&nbsp;</p>"},"replies":[]},{"id":"entry-2940114","entry":{"title":"breezy bird","time":"2021-07-05T06:36:04.000Z","msg":"<p>Input-Output System</p>\n<p>After reading the chapter, I would like to understand more about the levels of I/O Access.&nbsp; Like when to apply the four levels of access levels. Would it be okay to use a Level 3 access level for Level 0 application.</p>"},"replies":[]},{"id":"entry-2940286","entry":{"title":"relieved quail","time":"2021-07-05T07:03:15.000Z","msg":"<p>OPtimization</p>\n<p>&nbsp;</p>\n<p>How would one go about optimizing a processor?</p>"},"replies":[]},{"id":"entry-2940505","entry":{"title":"professional pigeon","time":"2021-07-05T16:09:12.000Z","msg":"<p><span style=\"font-size: 24pt;\">How dependent is C++ and Java on x86 processors?</span></p>"},"replies":[]},{"id":"entry-2942273","entry":{"title":"genuine gopher","time":"2021-07-06T05:19:27.000Z","msg":"<p>How do you translate unsigned decimal to binary?</p>"},"replies":[]},{"id":"entry-2949318","entry":{"title":"hilarious harrier","time":"2021-07-08T06:38:53.000Z","msg":"<p>What is the digital logic layer?</p>"},"replies":[]}]}