<!DOCTYPE html><html><head><meta charset="UTF-8"><title>M5: Content Question (Data Transfer, Addressing, Arithmetic )</title><link rel="stylesheet" href="style.css"></head><body><div class="topic"><h1>M5: Content Question (Data Transfer, Addressing, Arithmetic )</h1><div><p><span>Post questions about data&nbsp;transfer, addressing, and arithmetic.</span><span>&nbsp;Use the first line of your post as the subject of the post.</span></p></div></div><table><tbody><tr><td><table class="comment" style="margin-left: 0px;" id="entry-2964147"><tbody><tr><td>financial fowl posted at 2021-07-13T07:48:46.000Z</td></tr><tr><td><p><strong>ESI</strong></p><p>Why do we increment ESI by 2 or 4 as the bit size increases? Is there any explanation behind why this is the case? For example, why should I add 2 to ESI when it is 16-bit or 4 when it is 32-bit.</p></td></tr></tbody></table></td></tr><tr><td><table class="comment" style="margin-left: 40px;" id="entry-2964257"><tbody><tr><td>loose llama posted at 2021-07-13T14:50:27.000Z</td></tr><tr><td><p>The textbook section "4.4.2 Arrays" has examples of using the ESI register as a pointer.&nbsp; That is, ESI contains the address of an array so it points to an array.&nbsp; Pointers always point to bytes. &nbsp; Any general purpose register can be used as an a pointer.</p><p>When a register is used as a pointer, it contains an address that corresponds a specific BYTE of memory.&nbsp; If you want to point the next BYTE of memory, you increment the pointer by 1.&nbsp; 16 bit values are 2 bytes so if the register points to any array of 16 values, you need to increment by 2 to get to the next 16 bit value.&nbsp; 32 bit values are 4 bytes so if the register points to any array of 32 values, you need to increment by 4 to get to the next 32 bit value. &nbsp;</p><p>Here is what a 16 bit array containing 1122h, 3344h might look like in memory:</p><table style="border-collapse: collapse; width: 97.8682%; height: 140px;" border="1"><tbody><tr style="height: 28px;"><td style="width: 7.08289%; height: 28px;">Label</td><td style="width: 15.7874%; height: 28px;">Memory address</td><td style="width: 10.7265%; height: 28px;">Byte offset</td><td style="width: 11.1315%; height: 28px;">Array index</td><td style="width: 21.5054%; height: 28px;">Value at memory location</td><td style="width: 33.6509%; height: 28px;">Description</td></tr><tr style="height: 28px;"><td style="width: 7.08289%; height: 28px;">MyArray</td><td style="width: 15.7874%; height: 28px;">0A00B100h</td><td style="width: 10.7265%; height: 28px;">0</td><td style="width: 11.1315%; height: 28px;">0</td><td style="width: 21.5054%; height: 28px;">22h</td><td style="width: 33.6509%; height: 28px;">Low byte of first array element</td></tr><tr style="height: 28px;"><td style="width: 7.08289%; height: 28px;"></td><td style="width: 15.7874%; height: 28px;">0A00B101h</td><td style="width: 10.7265%; height: 28px;">1</td><td style="width: 11.1315%; height: 28px;"></td><td style="width: 21.5054%; height: 28px;">11h</td><td style="width: 33.6509%; height: 28px;">High byte of first array element</td></tr><tr style="height: 28px;"><td style="width: 7.08289%; height: 28px;"></td><td style="width: 15.7874%; height: 28px;">0A00B102h</td><td style="width: 10.7265%; height: 28px;">2</td><td style="width: 11.1315%; height: 28px;">1</td><td style="width: 21.5054%; height: 28px;">44h</td><td style="width: 33.6509%; height: 28px;">Low byte of second array element</td></tr><tr style="height: 28px;"><td style="width: 7.08289%; height: 28px;"></td><td style="width: 15.7874%; height: 28px;">0A00B103h</td><td style="width: 10.7265%; height: 28px;">3</td><td style="width: 11.1315%; height: 28px;"></td><td style="width: 21.5054%; height: 28px;">33h</td><td style="width: 33.6509%; height: 28px;">High byte of second array element</td></tr></tbody></table><p>Here is an example that uses the ESI as a pointer to the array:</p><pre>.data<br>MyArray WORD 1122h,3344h<br>.code<br>mov esi, offset MyArray ; esi points to address 0A00B100h (first array element)<br>mov ax, [esi] ; ax now has 16 bit value 1122h<br>add esi, 2 ; esi points to 0A00B100h+2=0A00B102h (second array element)<br>mov bx, [esi] ; bx now has 16 bit value 3344h</pre><p>Note that any other general purpose register could have been used instead of ESI.</p></td></tr></tbody></table></td></tr><tr><td><table class="comment" style="margin-left: 40px;" id="entry-2973171"><tbody><tr><td>grumpy haddock posted at 2021-07-16T18:33:46.000Z</td></tr><tr><td><p>ESI is incremented by 1, 2, or 4 based on the bit size because as you want to traverse through an array, you will need to increment based on the size. As such when you are using ESI to traverse, it will be incremented by 1 for byte, 2 for word, 4 for dword, and i think 8 for qword.</p></td></tr></tbody></table></td></tr><tr><td><table class="comment" style="margin-left: 40px;" id="entry-2977557"><tbody><tr><td>relaxed python posted at 2021-07-18T20:29:17.000Z</td></tr><tr><td><p>One byte equal to 8 bits. 16 bits equals to 2 bytes, and 32 bits equals to 4 bytes. When we add value to ESI, it usually be adding with byte, and this is why we add 2 to ESI when it is 16-bit, and add 4 when it is 32-bit.</p></td></tr></tbody></table></td></tr><tr><td><table class="comment" style="margin-left: 40px;" id="entry-2978811"><tbody><tr><td>advanced anaconda posted at 2021-07-19T04:29:38.000Z</td></tr><tr><td><p>The increment amount is counted in byte. Basically, you can determine it by calculating how many bytes are in the variable type. For example, a BYTE is 1, a WORD is 2, and DWORD is 4.</p></td></tr></tbody></table></td></tr><tr><td><table class="comment" style="margin-left: 0px;" id="entry-2965673"><tbody><tr><td>dizzy cuckoo posted at 2021-07-14T02:37:22.000Z</td></tr><tr><td><p>Hello all, I am having difficulty in grasping OFFSET: anyone can help to think it through? Thanks!</p><div class="page" title="Page 147"><div class="section"><div class="layoutArea"><div class="column"><p><span>OFFSET Operator</span></p><p><span>The OFFSET operator returns the offset of a data label. The offset represents the distance, in bytes, of the label from the beginning of the data segment. To illustrate, Figure 4-6 shows a vari- able named</span><span>myByte</span><span>inside the data segment.</span></p></div></div></div></div></td></tr></tbody></table></td></tr><tr><td><table class="comment" style="margin-left: 40px;" id="entry-2970670"><tbody><tr><td>supposed swordtail posted at 2021-07-15T23:30:23.000Z</td></tr><tr><td><p>Hello,</p><p>The OFFSET operator is analogous to the &amp; operator that returns a pointer to a value in C/C++. It's return value represents the location of memory of the beginning of the value relative to the location of the start of all the data.</p></td></tr></tbody></table></td></tr><tr><td><table class="comment" style="margin-left: 40px;" id="entry-2972673"><tbody><tr><td>insufficient junglefowl posted at 2021-07-16T06:51:01.000Z</td></tr><tr><td><p><span>Outside of 16-bit code on normal OSes. Virtual memory is flat and all the segments having base=0.</span></p><p><span>"An offset is the number of address location in based address in order to go to the specified absolute address."</span></p><p><span>This basically means it looks like an index (data item/field) of an array (data element/block/frame). An offset indicates the distance between the data item and data element. All of the items of an element are the same size (bytes/words).</span></p></td></tr></tbody></table></td></tr><tr><td><table class="comment" style="margin-left: 80px;" id="entry-2977585"><tbody><tr><td>dizzy cuckoo posted at 2021-07-18T20:52:44.000Z</td></tr><tr><td><p>Thanks Ronak and Summer! I spent quite some time digging into this concept and I finally got it!&nbsp;</p><p>&nbsp;</p><div class="page" title="Page 148"><div class="section"><div class="layoutArea"><div class="column"><p><span>mov esi,OFFSET bVal -&gt; return/get the address of the variable</span></p><p><span>By the same concept, OFFSET is also used to "traverse" the variable in its memory segment by adding "bytes" to locate next data in that address: such as: MOV eax, [ESI+4] -&gt; next element in the array.&nbsp;</span></p><p><span>Thanks again!</span></p></div></div></div></div></td></tr></tbody></table></td></tr><tr><td><table class="comment" style="margin-left: 40px;" id="entry-2977616"><tbody><tr><td>puzzled pony posted at 2021-07-18T21:10:26.000Z</td></tr><tr><td><p>This might be a helpful resource:</p><ul><li><a href="https://www.youtube.com/watch?v=ZZmVeohzXrA" class="external youtubed" target="_blank" rel="noreferrer noopener"><span>Assembly Language Tutorial 11: How to Display a Message &amp; use of OFFSET operator - YouTube</span><span aria-hidden="true" class="ui-icon ui-icon-extlink ui-icon-inline" title="Links to an external site."></span><span class="screenreader-only">&nbsp;(Links to an external site.)</span></a><a href="https://www.youtube.com/watch?v=ZZmVeohzXrA" class="youtubed"><img src="/images/play_overlay.png" class="media_comment_thumbnail" style="background-image: url(//img.youtube.com/vi/ZZmVeohzXrA/2.jpg)" alt=""></a></li></ul></td></tr></tbody></table></td></tr><tr><td><table class="comment" style="margin-left: 80px;" id="entry-2979499"><tbody><tr><td>thin tick posted at 2021-07-19T06:17:13.000Z</td></tr><tr><td><p>Thanks Phaniteja, I was having trouble understanding the use of OFFSET but this video definitely helped clear up some confusion. I will definitely have to check out some of the other assembly videos on that channel.</p></td></tr></tbody></table></td></tr><tr><td><table class="comment" style="margin-left: 80px;" id="entry-2979567"><tbody><tr><td>relieved quail posted at 2021-07-19T06:25:10.000Z</td></tr><tr><td><p>Thank you for posting this video!</p></td></tr></tbody></table></td></tr><tr><td><table class="comment" style="margin-left: 40px;" id="entry-2977924"><tbody><tr><td>entitled earwig posted at 2021-07-18T23:35:37.000Z</td></tr><tr><td><p>It just gives you the memory location of data, which you can then manipulate.</p><p>For example to traverse an array, you can take find the OFFSET of it, and then add to it to access higher locations in memory, which correspond to later elements in the array.</p></td></tr></tbody></table></td></tr><tr><td><table class="comment" style="margin-left: 40px;" id="entry-2978464"><tbody><tr><td>envious earwig posted at 2021-07-19T02:57:24.000Z</td></tr><tr><td><p>Hi! I also had trouble grasping this topic. Here's a link that I thought was helpful:<a href="https://stackoverflow.com/questions/39482404/offset-operator-in-assembly-language-for-x86-processors" target="_blank" class="external" rel="noreferrer noopener"><span>https://stackoverflow.com/questions/39482404/offset-operator-in-assembly-language-for-x86-processors</span><span aria-hidden="true" class="ui-icon ui-icon-extlink ui-icon-inline" title="Links to an external site."></span><span class="screenreader-only">&nbsp;(Links to an external site.)</span></a></p><p>&nbsp;</p></td></tr></tbody></table></td></tr><tr><td><table class="comment" style="margin-left: 0px;" id="entry-2968326"><tbody><tr><td>professional pigeon posted at 2021-07-15T04:01:02.000Z</td></tr><tr><td><p>best practice in setting pointers and addresses in assembly?</p></td></tr></tbody></table></td></tr><tr><td><table class="comment" style="margin-left: 40px;" id="entry-2980549"><tbody><tr><td>entitled earwig posted at 2021-07-19T18:47:40.000Z</td></tr><tr><td><p>Yes, I think setting pointers are one of the best practices when it comes to assembly. But it is very important to understand setting pointers because many things could go wrong if the pointers are set wrong / misused. For example, memory leaks could occur, some sort of access could be violated, there could be a null pointers exception or an overflow and so the list goes on. Similar problems could occur with addresses when setting them in assembly.</p><p>&nbsp;</p></td></tr></tbody></table></td></tr><tr><td><table class="comment" style="margin-left: 0px;" id="entry-2973627"><tbody><tr><td>consistent centipede posted at 2021-07-16T22:07:13.000Z</td></tr><tr><td><p>On page 121 of the textbook, there is an example of Pointers, where a line: ptrB dword arrayB could also be written as ptrB dword OFFSET arrayB. What are the differences between these two lines, and when should we use one or the other?</p></td></tr></tbody></table></td></tr><tr><td><table class="comment" style="margin-left: 0px;" id="entry-2975381"><tbody><tr><td>passive owl posted at 2021-07-17T07:09:56.000Z</td></tr><tr><td><h4><strong>Difference between Protected mode's OFFSET Operator and Real mode's OFFSET Operator</strong></h4><p>I can see there are Protected mode:32 bit and Real mode:16 bit for the OFFSET Operator. What is the difference for the OFFSET Operator in two different modes?</p></td></tr></tbody></table></td></tr><tr><td><table class="comment" style="margin-left: 40px;" id="entry-2976035"><tbody><tr><td>statutory squirrel posted at 2021-07-17T23:37:46.000Z</td></tr><tr><td><p>Pretty sure in protected mode its a 32 bit long offset and in real mode its a 16 bit long offset.&nbsp;</p><p>Here is a resource:<a href="http://www.c-jump.com/CIS77/ASM/Instructions/I77_0180_offset_operator.htm" target="_blank" class="external" rel="noreferrer noopener"><span>http://www.c-jump.com/CIS77/ASM/Instructions/I77_0180_offset_operator.htm</span><span aria-hidden="true" class="ui-icon ui-icon-extlink ui-icon-inline" title="Links to an external site."></span><span class="screenreader-only">&nbsp;(Links to an external site.)</span></a></p><p>&nbsp;</p></td></tr></tbody></table></td></tr><tr><td><table class="comment" style="margin-left: 40px;" id="entry-2977392"><tbody><tr><td>tough toad posted at 2021-07-18T18:57:54.000Z</td></tr><tr><td><p>I think this article might also help.</p><p>https://titanwolf.org/Network/Articles/Article?AID=d3abc0a4-c8b5-4136-8437-cb766174752d#gsc.tab=0</p></td></tr></tbody></table></td></tr><tr><td><table class="comment" style="margin-left: 40px;" id="entry-2977686"><tbody><tr><td>implicit hoverfly posted at 2021-07-18T21:43:46.000Z</td></tr><tr><td><p>I found a good video to refer to. I hope this is helpful to you.</p><p>https://www.youtube.com/watch?v=5hikXYBOppU</p></td></tr></tbody></table></td></tr><tr><td><table class="comment" style="margin-left: 80px;" id="entry-2979041"><tbody><tr><td>abstract aardwolf posted at 2021-07-19T05:09:43.000Z</td></tr><tr><td><p>Thanks! The video was very helpful to me.</p></td></tr></tbody></table></td></tr><tr><td><table class="comment" style="margin-left: 40px;" id="entry-2979892"><tbody><tr><td>skilled silkworm posted at 2021-07-19T06:58:29.000Z</td></tr><tr><td><p><span>OFFSET is to be used for global variables and ADDR for local variables. ADDR could ALSO be used while referring to global variables, BUT OFFSET cannot be used while referring to local variables.</span></p></td></tr></tbody></table></td></tr><tr><td><table class="comment" style="margin-left: 40px;" id="entry-2979915"><tbody><tr><td>skilled silkworm posted at 2021-07-19T07:00:13.000Z</td></tr><tr><td><p>I have a link for a reference<a class="inline_disabled external" href="https://www.hitxp.com/articles/software/difference-between-addr-and-offset/" target="_blank" rel="noreferrer noopener"><span>https://www.hitxp.com/articles/software/difference-between-addr-and-offset/</span><span aria-hidden="true" class="ui-icon ui-icon-extlink ui-icon-inline" title="Links to an external site."></span><span class="screenreader-only">&nbsp;(Links to an external site.)</span></a></p></td></tr></tbody></table></td></tr><tr><td><table class="comment" style="margin-left: 0px;" id="entry-2975986"><tbody><tr><td>easy dolphin posted at 2021-07-17T23:08:18.000Z</td></tr><tr><td><p><strong>Order of Bytes when addressing them&nbsp;</strong></p><p>Hello everyone. I'm not sure if this was mentioned somewhere in the lectures or textbook (I might have missed it, so apologies for that) but I wanted to confirm this - While addressing an array of any type the addressing order is from the left, and when addressing the non-array value of a datatype (let's say DWORD 12345h) we start from the right? Please clarify this. Thank you.</p></td></tr></tbody></table></td></tr><tr><td><table class="comment" style="margin-left: 40px;" id="entry-2977425"><tbody><tr><td>electoral dragon posted at 2021-07-18T19:18:51.000Z</td></tr><tr><td><p>They talked about it in the previous chapter but it depends on your assembler. For MASM what you said is correct except I dont think the h for hexadecimal is counted.</p></td></tr></tbody></table></td></tr><tr><td><table class="comment" style="margin-left: 40px;" id="entry-2978757"><tbody><tr><td>faithful firefly posted at 2021-07-19T04:16:35.000Z</td></tr><tr><td><p>That's right. Here's what an integer would look like in memory. For an array, the bytes would be ordered.&nbsp;</p><p>&nbsp;</p><table style="border-collapse: collapse; width: 97.8578%; height: 58px;" border="1"><tbody><tr><td style="width: 24.9751%;">One DWORD</td><td style="width: 24.9751%;">One byte</td><td style="width: 24.9751%;">Byte Array</td><td style="width: 24.9751%;">Word array</td></tr><tr style="height: 29px;"><td style="width: 24.9751%; height: 29px;"><img src="https://deanza.instructure.com/users/178550/files/5583266/preview?verifier=UOYYeQjNDV1oFRbuYYsYGGmvLXYKvPC7PRt1jhWm" alt="data.GIF" data-api-endpoint="https://deanza.instructure.com/api/v1/users/178550/files/5583266" data-api-returntype="File" style="max-width: 220px;"></td><td style="width: 24.9751%; height: 29px;"><img src="https://deanza.instructure.com/users/178550/files/5583328/preview?verifier=eX1AqsroG1EE2hvFHc9UmNhTVA5Hj3Xa7UanDFMk" alt="bytescode.GIF" data-api-endpoint="https://deanza.instructure.com/api/v1/users/178550/files/5583328" data-api-returntype="File" style="max-width: 139px;">&nbsp;</td><td style="width: 24.9751%; height: 29px;">&nbsp;<img src="https://deanza.instructure.com/users/178550/files/5583338/preview?verifier=0upzPWM47KMcFYmx7glga3tLgMo3EmhV6FIRmwN6" alt="bytearraycode.GIF" data-api-endpoint="https://deanza.instructure.com/api/v1/users/178550/files/5583338" data-api-returntype="File" style="max-width: 249px;">&nbsp;</td><td style="width: 24.9751%; height: 29px;"><img src="https://deanza.instructure.com/users/178550/files/5583331/preview?verifier=uh3rv01qkeqG3cjgPqBKCXwNbZmSjnPDbteWCL9C" alt="wordcode.GIF" data-api-endpoint="https://deanza.instructure.com/api/v1/users/178550/files/5583331" data-api-returntype="File" style="max-width: 249px;"></td></tr><tr style="height: 29px;"><td style="width: 24.9751%; height: 29px;"><img src="https://deanza.instructure.com/users/178550/files/5583270/preview?verifier=V18G0w8AlEHwBlT92NTFLYYjL6UBjUuJy53RWMnb" alt="Memory.GIF" data-api-endpoint="https://deanza.instructure.com/api/v1/users/178550/files/5583270" data-api-returntype="File" style="max-width: 172px;"></td><td style="width: 24.9751%; height: 29px;"><img src="https://deanza.instructure.com/users/178550/files/5583343/preview?verifier=KZy1DxMsX9L5fD8KvO5K263JQuUOpwLPBYS9Y4nh" alt="bytemem.GIF" data-api-endpoint="https://deanza.instructure.com/api/v1/users/178550/files/5583343" data-api-returntype="File" style="max-width: 172px;">&nbsp;</td><td style="width: 24.9751%; height: 29px;"><img src="https://deanza.instructure.com/users/178550/files/5583347/preview?verifier=ZODkU2GrU3g1c5g062gWZWHMibhKlJ0ExJMDemfd" alt="bytearraymem.GIF" data-api-endpoint="https://deanza.instructure.com/api/v1/users/178550/files/5583347" data-api-returntype="File" style="max-width: 168px;">&nbsp;</td><td style="width: 24.9751%; height: 29px;"><img src="https://deanza.instructure.com/users/178550/files/5583349/preview?verifier=b9ajlocJ5nW6NyevHoKqaHm6lgSTTW11f4u2gAnX" alt="dwordmem.GIF" data-api-endpoint="https://deanza.instructure.com/api/v1/users/178550/files/5583349" data-api-returntype="File" style="max-width: 168px;">&nbsp;</td></tr></tbody></table><p>&nbsp;</p></td></tr></tbody></table></td></tr><tr><td><table class="comment" style="margin-left: 0px;" id="entry-2977430"><tbody><tr><td>hilarious harrier posted at 2021-07-18T19:20:23.000Z</td></tr><tr><td><p>In the book he uses this line to demonstrate the carry flag</p><p>mov eax,0FFFFFFFFh</p><p>is there a reason for the 0 in the front</p></td></tr></tbody></table></td></tr><tr><td><table class="comment" style="margin-left: 40px;" id="entry-2977892"><tbody><tr><td>financial fowl posted at 2021-07-18T23:24:27.000Z</td></tr><tr><td><p>The 0 is used to indicate that it is a positive number.&nbsp;</p></td></tr></tbody></table></td></tr><tr><td><table class="comment" style="margin-left: 80px;" id="entry-2979439"><tbody><tr><td>surviving takin posted at 2021-07-19T06:09:38.000Z</td></tr><tr><td><p>Thanks! I was (sadly) confused by that too.</p></td></tr></tbody></table></td></tr><tr><td><table class="comment" style="margin-left: 80px;" id="entry-2979830"><tbody><tr><td>conceptual catfish posted at 2021-07-19T06:52:31.000Z</td></tr><tr><td><p>Thank you I was also unsure about this.</p></td></tr></tbody></table></td></tr><tr><td><table class="comment" style="margin-left: 40px;" id="entry-2979822"><tbody><tr><td>overseas orca posted at 2021-07-19T06:51:36.000Z</td></tr><tr><td><p>The 0 means the number is positive.</p></td></tr></tbody></table></td></tr><tr><td><table class="comment" style="margin-left: 0px;" id="entry-2977756"><tbody><tr><td>occasional muskox posted at 2021-07-18T22:16:10.000Z</td></tr><tr><td><p>What exactly is "sign extension"? I'm having a little trouble understanding that page of the book.</p></td></tr></tbody></table></td></tr><tr><td><table class="comment" style="margin-left: 40px;" id="entry-2978504"><tbody><tr><td>brief bird posted at 2021-07-19T03:06:57.000Z</td></tr><tr><td><p>Hey Arjun! I found this resource to be helpful in understanding sign extension.</p><p><a href="http://www.c-jump.com/CIS77/CPU/Numbers/U77_0160_sign_extension.htm" target="_blank" class="external" rel="noreferrer noopener"><span>http://www.c-jump.com/CIS77/CPU/Numbers/U77_0160_sign_extension.htm</span><span aria-hidden="true" class="ui-icon ui-icon-extlink ui-icon-inline" title="Links to an external site."></span><span class="screenreader-only">&nbsp;(Links to an external site.)</span></a></p><p>Hope it helps you!</p></td></tr></tbody></table></td></tr><tr><td><table class="comment" style="margin-left: 0px;" id="entry-2977798"><tbody><tr><td>genuine gopher posted at 2021-07-18T22:32:03.000Z</td></tr><tr><td><p>Direct memory operations</p><p>What does it mean when the label is automatically dereferenced by the assembler?</p></td></tr></tbody></table></td></tr><tr><td><table class="comment" style="margin-left: 40px;" id="entry-2978174"><tbody><tr><td>spatial snipe posted at 2021-07-19T01:12:13.000Z</td></tr><tr><td><p>As per my understanding of 4.1.3,&nbsp; when we declare variables in .data section, each variable will be assigned with a memory address.&nbsp; And when we use that variable name in the .code portion, assembler will directly reference the memory location of the variable, which is nothing but direct memory operands.&nbsp;&nbsp;</p><p>As additional quirk to MASM compared to other assemblers, square brackets [] is used as dereferencing operator, but MASM uses dereference regardless.&nbsp;</p><div class="page" title="Page 132"><div class="section"><div class="layoutArea"><div class="column"><p><span>mov al var1&nbsp; ; let var1 is having some memory offset 00010h</span></p><p><span>then</span></p><p><span>A0 00000010</span></p><p><span>will be the assembly code (notice the direct reference to memory of the variable). Hope this helps.</span></p></div></div></div></div></td></tr></tbody></table></td></tr><tr><td><table class="comment" style="margin-left: 0px;" id="entry-2978024"><tbody><tr><td>geographical gopher posted at 2021-07-19T00:17:05.000Z</td></tr><tr><td><p>Reading through the presentation for 04 I wanted to get a quick sanity check:</p><p>&nbsp;</p><p>Slide 40 it has:&nbsp;</p><ul><li aria-level="1"><span>When adding two integers, remember that the Overflow flag is only set when . . .</span></li><ul><li aria-level="2"><span>Two positive operands are added and their sum is negative</span></li><li aria-level="2"><span>Two negative operands are added and their sum is positive</span></li></ul></ul><p>&nbsp;</p><p><span>The signs ony flip due to overflow, but isn't the output of this in the ALU going to be that the data values contain the remainder, the sign bit wouldn't have changed, and the carry / OF flag would be set? I know some ALUs will just carry that bit over into the sign bit but I thought most modern computers don't do that.</span></p></td></tr></tbody></table></td></tr><tr><td><table class="comment" style="margin-left: 0px;" id="entry-2978270"><tbody><tr><td>enormous earthworm posted at 2021-07-19T01:53:09.000Z</td></tr><tr><td><p><strong>Displaying an Array In the Visual Studio Debugger</strong></p><p>The Instructions from this section are out of date. How would I get the debugger memory window in VS2019.</p></td></tr></tbody></table></td></tr><tr><td><table class="comment" style="margin-left: 40px;" id="entry-2979511"><tbody><tr><td>close buzzard posted at 2021-07-19T06:18:15.000Z</td></tr><tr><td><p>Hi Jason,</p><p>You need to be in debug mode (i.e. set a breakpoint) to see the memory menus.</p><p>As for things being outdated, menus in software usually don't change over time. It's all for the users and their muscle memory that developers avoid changing where things are.</p></td></tr></tbody></table></td></tr><tr><td><table class="comment" style="margin-left: 0px;" id="entry-2978532"><tbody><tr><td>secure salamander posted at 2021-07-19T03:13:12.000Z</td></tr><tr><td><p>This is more so overall information rather than just M5 but on page 587, you can see all the information on MASM such as reserved words, register names, operators, and much more. It goes all the way to page 643.</p></td></tr></tbody></table></td></tr><tr><td><table class="comment" style="margin-left: 0px;" id="entry-2978923"><tbody><tr><td>ugliest trout posted at 2021-07-19T04:50:05.000Z</td></tr><tr><td><p><span style="font-size: 14pt;">OFFSET</span></p><p><span style="font-size: 12pt;">What is the use of offset? Is it just return?</span></p></td></tr></tbody></table></td></tr><tr><td><table class="comment" style="margin-left: 40px;" id="entry-2979234"><tbody><tr><td>Deleted by conscious cattle on Jul 18 at 10:45pm posted at null</td></tr><tr><td></td></tr></tbody></table></td></tr><tr><td><table class="comment" style="margin-left: 40px;" id="entry-2979276"><tbody><tr><td>conscious cattle posted at 2021-07-19T05:47:03.000Z</td></tr><tr><td><p>Hey Jimmy, I found this quite helpful to understand the use of offset in assembly language.</p><p><a class="external" href="https://stackoverflow.com/questions/22677997/what-are-offsets-in-assembly-and-how-do-i-use-them" target="_blank"><span>arm - What are offsets in Assembly and how do I use them? - Stack Overflow</span><span class="screenreader-only">&nbsp;(Links to an external site.)</span></a></p><p>I hope that helps.</p></td></tr></tbody></table></td></tr><tr><td><table class="comment" style="margin-left: 0px;" id="entry-2978994"><tbody><tr><td>moaning mastodon posted at 2021-07-19T05:01:30.000Z</td></tr><tr><td>How would I transfer data from one register from another? Isn’t that an error?</td></tr></tbody></table></td></tr><tr><td><table class="comment" style="margin-left: 40px;" id="entry-2979068"><tbody><tr><td>Cole Gannon posted at 2021-07-19T05:15:06.000Z</td></tr><tr><td><p>mov eax,ebx would work for example. Moving from memory to memory is an error.</p></td></tr></tbody></table></td></tr><tr><td><table class="comment" style="margin-left: 40px;" id="entry-2979404"><tbody><tr><td>agricultural ant posted at 2021-07-19T06:04:49.000Z</td></tr><tr><td><p>You only get an error when moving from memory to memory, moving from register to register shouldn't be an issue as far I know.&nbsp;</p></td></tr></tbody></table></td></tr><tr><td><table class="comment" style="margin-left: 0px;" id="entry-2979352"><tbody><tr><td>driving deer posted at 2021-07-19T05:58:04.000Z</td></tr><tr><td><p><strong>Flags Affected by Addition and Subtraction</strong></p><p>Does anyone have any good resources for the different flags and the types of arithmetic instructions and cases where each type of flag is set. After reading the section from the textbook (4.2.6), I am still a bit confused and could use some more examples.&nbsp;</p></td></tr></tbody></table></td></tr><tr><td><table class="comment" style="margin-left: 40px;" id="entry-2979447"><tbody><tr><td>surviving takin posted at 2021-07-19T06:10:34.000Z</td></tr><tr><td><p>Hi Aryan,</p><p>&nbsp;</p><p>I found<a class="inline_disabled external" href="http://service.scs.carleton.ca/sivarama/asm_book_web/Instructor_copies/ch6_arithmetic.pdf" target="_blank" rel="noreferrer noopener"><span>this</span><span aria-hidden="true" class="ui-icon ui-icon-extlink ui-icon-inline" title="Links to an external site."></span><span class="screenreader-only">&nbsp;(Links to an external site.)</span></a>resource to be helpful!</p></td></tr></tbody></table></td></tr><tr><td><table class="comment" style="margin-left: 80px;" id="entry-2980049"><tbody><tr><td>civic bovid posted at 2021-07-19T08:26:30.000Z</td></tr><tr><td><p>This is a great material. Thank you</p></td></tr></tbody></table></td></tr><tr><td><table class="comment" style="margin-left: 0px;" id="entry-2979489"><tbody><tr><td>breezy bird posted at 2021-07-19T06:15:42.000Z</td></tr><tr><td><p><strong>Indexed Operands</strong></p><p>What is the purpose of indexed operands? And what are the different notational forms permitted by MASM?</p></td></tr></tbody></table></td></tr></tbody></table></body></html>